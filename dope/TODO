habe nochmal das mit dem operator| probiert
in experiments/pipe.cpp
aber toll ist das wirklich nicht
der ganze aufwand nur um den . durch ein | zu ersetzen ist
ja wohl stumpfsinnig


wieder einmal das config.h problem
soll es installiert werden ?
soll es anders heiﬂen
wer soll es includen und wie <> vs ""


entferne name extension
und mache als beispiel einer extension eine comment extension
und denke erst nochmal ueber extensions nach und verkn¸pfe traits irgendwie
mit der extension klasse


build process:
think about inter-library dependencies again
in fact I think dope-config should be used for this and not libtool
=> perhaps remove configuration option again
but then dope-config should check if the library it depends upon are still there ?
or at least AM_PATH_DOPE should do this
find a example how to do this


mir fehlt das konzept von anfang und ende
also der erste simple muss sich von anderen unterscheiden
brauche ich staendig bei netzwerk-kram z.bsp http-stream
und bei xml (root-node)
...
im moment benutze ich flush in diese richtung
lsg.: 
user benutzt nicht direkt simple sondern was anderes
oder ich mache dass ein stream immer nur ein objekt lesen/schreiben kann
aber das waere doof ?


also 
scheiﬂe
mit den manipulatoren

das mit den traits richtig gut machen
evtl. noch mal dar¸ber nachdenken wie sich das mit vererbung bei streams
vertreagt
die operator overload geschichte soll nicht aufgezwungen werden
nochmal ueber das problem der rueckgabewerte nachdenken (im zusammenhang mit ableiten z.bsp rawoutstream)



gute idee:
erweiterbarkeit muﬂ ich sicherstellen
das koennte ich mit einer generischen methode info machen
dann kann jeder stream eine default impl. haben die nichts macht
also
template <typename X>
stream &info(X)
{
}
oder evtl. ext(X)

so koennte ich auch die name() geschichte machen und dann w¸rde es reichen bei
XTL eben die default impl hinzuzuf¸gen
bei XML koennte man da die namespace geschichten mit machen (und DTD - ACHTUNG DTD und 
namespaces vertragen sich anscheinend nicht - dann muesste man xml schema benutzen was
aber anscheinend von libxml noch nicht unterst¸tzt wird)
v.a. reicht der typ bei fixen sachen und somit kann der compiler mehr optimieren
aber strings sind keine template prarameter oder ?
und das def_gettypename zeugs koennte verschwinden
sollte auf jedenfall umbenannt werden in REGISTER_TYPE oder so

das problem mit der methode ist natuerlich dass kein compile-time check mehr
existiert ob alle notwendige information geg. ist => runtime-fehler
was sind die alternativen ?
streams von einer basisklasse mit empty default methoden ableiten
dann m¸ﬂte ich nur die basis-klasse ‰ndern.


ich muﬂ unbedingt die schnittstelle fuer layer 2 streams exakt festlegen
evtl. verschieden die dann ueber type traits identifizierbar sind
und dann muﬂ endlich ein multi-ptokoll stream als beispiel her
und ne app -- auﬂerdem ein bsp. c++ <-> java
und xmlrpc
dann muﬂ xslt integriert werden




* leak tracing - currently i have problems to get LeakTracer to work with
  gcc-3.0 but perhaps the std c++ lib "leaks"

* const correctness
  search for const_cast !! const_cast removes const => no const guarantee
  f.e. const int a=5;
  a=3; => compiller error
  but const_cast<int &>(a)=3; => no compiler error but runtime error
  i replaced the const_cast with static_cast => now compiler reports warnings
  => I will not forget it
  the main problem is perhaps std::map

  my problem is a don't want to have the user to write the same method twice
  the const and non-const variant => i need some template trick but the const attribute of a method
  can not be templated ?
  how to solve this ?
  or i simply say - sorry no const write - but this could get annoying
  my current solution is that i know my write is const (or i hope) and then use const_cast
  to fake the const.

* error reporting with streambuf (layer0)
  especially the saxwrapper must report errors to the sax parser
  should work now - but needs a review

* the type -> typename mapping is still ugly
  add a template parameter to make it flexible

* w_char support - UNICODE ?

* documentation

* examples

* automatic testsuite

* xmlrpc
  xmlrpc is quite stupid
* soap
  soap seems to be even worse

* test with JSX
  i didn't get jsx to work correctly

* DTD / xml schema
  just a matter of writing a stream adapter

* scheme/guile
  accesing data from scheme is a bit tricky
  don't know yet which is the best representation of a object in scheme
  the only portable solution seems to produce a string and use eval   

* CORBA (use GIOP from XTL)
  can't find a simple docu how to pass a message to corba
  seems I have to learn more about corba first - unfortunately I don't like corba

* libsigc++
  works

* allow xslt tansformations
  the problem is I can't find a xslt processor which doesn't build a DOM of the document to transform
  => memory usage linear to document size
  => only suitable for small objects/documents
  since xmlsaxinstream is very slow i wanted to add a xmldominstream anyway
  => add a xmlsaxdomoutstream, too
  those streams would then be the right choice for small objects

performance problems with c++ streams
my own streams do not implement sputn sgetn => read write with one byte - i will change this
unfortunately it seems g++ (3.0.3) streambufs write also only 1 byte - strace shows this (can't believe
that it will stay like this)
